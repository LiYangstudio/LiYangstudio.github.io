

---
layout: 【JVM】初级GC算法
title:【IntentService】原理解析
desc: 我的博客系统介绍
keywords: 'blog'
date: 2016-11-07T00:00:00.000Z
categories:
- life
tags:
- life
icon: icon-life
---
<!-- more -->
## 参考资料

* 深入理解Java虚拟机

* [Android梦想特工队 - JAVA垃圾回收机制](http://www.wxtlife.com/2016/04/25/java-jvm-gc/?hmsr=toutiao.io) 

## Java垃圾对象标记

* 1.引用计数

    * 缺点：无法解决循环引用

    * （Object-C采用该算法）

* 2.可达性分析算法

    * 从GC Root作为起点，搜索引用的对象，生成一棵引用树，树的节点视为可达对象，反之不可以达

    * 可作为GC Root的对象：

        *  虚拟机栈（栈帧中的本地变量表）中的引用对象

        * 方法区中的类静态属性引用的对象

        * 方法区中的常量引用的对象

        * 本地方法栈中JNI（Native方法）的引用对象

    * 此方法用来替代引用计数，解决引用计数存在的问题

 

## JVM 初级GC算法

* 1.标记清除算法

* 2.复制算法

* 3.标记压缩算法



### 标记清除回收算法

流程：

* 分两阶段

* 第一阶段从引用根节点开始标记所有被引用的对象

* 第二阶段遍历整个堆，把未标记的对象清除



![标记清除回收算法示意图](http://p1.bpimg.com/567571/3e1f00a931a2f1da.png)

 

优点：

* 实现简单



缺点：

* 此算法需要暂停整个应用

* 会产生内存碎片 



### 复制回收算法

流程：

* 此算法把内存空间划为两个相等的区域，每次只使用其中一个区域

* 垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中



![复制回收算法示意图](http://p1.bpimg.com/567571/df9f389e3c85cd8c.png)

 

优点：

* 算法每次只处理正在使用中的对象，因此复制成本比较小（但是多的话也会影响效率）

* 同时复制过去以后还能进行相应的内存整理，不会出现 " 碎片 " 问题



缺点：

* 缺点也是很明显的，就是需要两倍内存空间

* 内存利用率较低



### 标记压缩回收算法

流程：

* 此算法结合了 " 标记 - 清除 " 和 " 复制 " 两个算法的优点。

* 第一阶段从根节点开始标记所有被引用对象

* 第二阶段遍历整个堆，把清除未标记对象并且把存活对象 " 压缩 " 到堆的其中一侧，按顺序排放 



![标记压缩回收算法示意图](http://p1.bpimg.com/567571/131fceb5662fe220.png)

 

优点：

* 此算法避免了 " 标记 - 清除 " 的碎片问题，同时也避免了 " 复制 " 算法的空间问题


**-Hans**
