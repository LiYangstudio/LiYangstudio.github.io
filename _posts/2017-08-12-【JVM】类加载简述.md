

<!-- more -->
## 参考资料

* 深入理解Java虚拟机

* [SegmentFault - Java类加载机制](https://segmentfault.com/a/1190000004597758)

## 简述步骤

详细六步：

![类加载六大步骤](http://p1.bpimg.com/567571/b722b1616255bbdf.png)

上图可以简化为：

一个完整的类加载过程必须经历加载、连接、初始化这三个步骤：

![类加载简化步骤](http://p1.bpimg.com/567571/60fc57b67d71525f.png)

## 加载

* 根据全限定名（带上包名）通过二进制流读入JVM内部

* JVM将该字节码**静态存储结构**（如.class文件）转化为**运行时结构**保存到方法区

* 在方法区生成一个Class类，作为该类入口



特别注意第一点，JVM只是根据全限定名来读取二进制流，而没有说一定是从.class文件中

* 从Zip包获取，衍生出后来的jar包、ear、war和包括**Android中的Dex**等等

* 从网络中获取，典型的Java Applet（虽然已经过时）

* 从其他文件生成，如JSP转化为Class类；还有Juby、Jhython等其他语言都是生成.class文件然后能够在JVM中执行

* 动态代理技术，在java.lang.relect.Proxy中，用ProxyGenerator.generateProxyClass为特定的接口生成“$Proxy”代理类的二进制流



备注：动态代理技术可以参考以下两篇文章：

[Android沉思录 - Android公共技术点之四-Java动态代理](http://yeungeek.com/2016/05/19/Android%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%E5%9B%9B-Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/)

[codeKK - 公共技术点之 Java 动态代理](http://p.codekk.com/blogs/detail/54cfab086c4761e5001b253d)



## 连接

目的：将JVM二进制字节流数据的类数据信息合并到JVM运行时的状态中

三个阶段：

* 1.验证

* 2.准备

* 3.解析



### 验证阶段

相对于C/C++来说，Java是相对安全的语言：

* 无法数组越界

* 对象转型无法转换为为实现的类型

* 不允许跳转到不存在的代码行数

如果这样做Java编译器会拒绝通过，但是加载也是说了Class文件的二进制流不一定来自编译器编译的.class文件。所以存在开发者直接操作字节码的可能，所以验证这一步非常有必要。



验证阶段分为四个阶段：

* 1.文件格式验证：是否以魔数0xCAFEBABE开头、主次版本范围是否在当前虚拟机处理范围、常量池是否有不支持的常量....等等

* 2.元数据验证：

    * 对字节码信息进行语义分析

    * 是否有父类

    * 是否继承不允许被继承的类

    * 是不是抽象类

    * ...等等

* 3.字节码验证：

    * 最为复杂的阶段

    * 保证操作数与操作类型匹配

    * 保证跳转指令不会跳转出方法体以外的指令...  

    * 这个阶段验证时间也会很长，所以JDK1.6之后在JVM和编译器在方法的Code属性中增加一个StackMapTable属性，用这个属性描述方法体的基本块。那么在验证时就不需要根据程序推导，只需检查StackMapTable属性即可。但是理论上StackMapTable也是存在串改可能

* 4.符号引用验证：

    * 发生在JVM将符号引用转化为直接引用的时候（在连接的第三阶段 解析的时候发生）

    * 通过权限定名能否找到类

    * 类、字段、方法的访问合法性（public protected private default）

    * ....

### 准备阶段

准备阶段比较简单，可以概括为：为类进行内存分配，如：初始化常量等



### 解析阶段

解析阶段：符号引用替换为直接引用的过程

符号引用：使用一组符号来描述所引用的目标，可以用任何字面量，只要能够无歧义地定位即可。不一定在内存。

直接引用：直接引用是可以直接指向目标的指针，目标已经在内存中。

## 初始化

初始化阶段也很简单：最贴近开发者的阶段，初始化static final成员变量、方法等




