

---
layout: post
title:【JVM】内存分配与回收策略
desc: 我的博客系统介绍
keywords: 'blog'
date: 2016-11-07T00:00:00.000Z
categories:
- life
tags:
- life
icon: icon-life
---
<!-- more -->
## 参考资料

* 深入理解Java虚拟机



## 概述

分配与回收策略并不是固定的，细节取决于当前虚拟机的垃圾收集器的组合以及参数设置等；

但可以了解几个普遍的策略：

* 对象优先在Eden区分配

* 大对象直接进入老年代

* 长期存活对象进入老年代

* 动态对象年龄判断

* 空间分配担保



## 对象优先在Eden区分配

大多数情况下，新建的对象都是在Eden区分配。若当前Eden区空间不足时，就会触发一次Minor GC，回收空间。



## 大对象直接进入老年代

大对象指的是，需要占用大量连续内存空间的对象：数字、很长的字符串等等

及时内存存在足够大的空间，但是由于不连续，也需要提前触发垃圾回收机制，来进行内存的回收压缩



## 动态对象年龄判断

虚拟机采用分代思想来管理对象，那么虚拟机就需要识别哪些对象是放在新生代、老年代的。

为此虚拟机给每一个对象设置了一个年龄计数器。如果该对象在Eden区，经过一次Minor GC之后依然存活，并且能被Survivor区容纳的话，就移动到Survivor空间，并且年龄+1。

达到一定年龄之后（默认15），对象就会提升到老年代。



## 空间分配担保

过程描述：

* 1.在发生Minor GC的时候，虚拟机会检查老年代最大的可用连续空间是否大于新生代所有对象的总空间

* 2.如果上述条件成立，那么则此次Minor GC是安全的。（因为老年代有足够大的空间将所有的对象容纳进去）

* 3.如果上述条件不成立，那么虚拟机就需要查看是否允许担保失败。

* 4.如果不允许，则直接触发一次Major GC（Full GC）。

* 5.如果允许，那么则要逐一检查老年代的最大可用连续空间是否大于历次晋升到老年代对象的平均大小；如果大于，则会**冒险尝试**进行一次Minor GC

### 疑问一

对于第1步，有一个疑问：用老年代最大连续空间与新生代所有对象总空间比较？

个人见解：

* 其实我觉得老年代最大连续空间大于所有对象的平均大小或者大于最大对象的空间即可（深入理解Java虚拟机一书里面是这样写到，目前还没有想明白）

* 但不能用老年代的可以使用的总空间与新生代的已占用的总空间比较。原因是假设新生代有一个要求连续空间的对象，而老年代并没有足够大的连续空间进行分配。这里就应该触发Major GC了，所以Minor GC此时是不安全的

### 疑问二

为何是历次晋升到老年代对象的平均大小？以及为何是冒险尝试？

原因如下：

* 新生代采用的复制算法，为了内存的利用率，只使用一个Survivor进行轮换备份

* 因此当大量的对象在一次Minor GC还存活的时候（极端情况下，全部都存活），此时就需要    老年代进行担保分配（即老年代需要保证能够将所有新生代存活的对象全部保存）

* 不过当Minor GC还没有触发时，老年代并不能知道新生代会存活下多少对象（即要求多大的对象），那么老年代只能根据以往的历次晋升到老年代对象大小的平均值作为参考，与剩余空间作对比，决定是否不触发Minor GC，而是触发Major GC（Full GC）

* 当时由于平均值是一个估算，并不一定能够满足当前的新生代中最大对象的要求，所以是冒险进行Major GC，如果失败的话还是要重新进行一次Major GC

**-Hans**
